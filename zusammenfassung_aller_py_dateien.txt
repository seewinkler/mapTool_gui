

# === Datei: main.py ===

import sys
import os

print("â–¶ Starte GUI-EntryPoint aus", __file__)

# Projekt-Root ins sys.path (damit gui/ und utils/ als Packages erkannt werden)
PROJECT_ROOT = os.path.abspath(os.path.dirname(__file__))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

# Logging & Config
from utils.logging_config import setup_logging
from utils.config         import CONFIG

setup_logging(CONFIG["logging"])

# Qt-App, Composer, View & Controller koppeln
from PySide6.QtWidgets                import QApplication
from gui.map_composer                 import MapComposer
from gui.main_window                  import MainWindow
from gui.controllers.main_controller  import MainController

def main():
    app      = QApplication(sys.argv)
    composer = MapComposer(CONFIG, [])
    window   = MainWindow(composer, CONFIG)
    controller = MainController(composer, window)
    sys.exit(controller.run())

if __name__ == "__main__":
    main()

# === Datei: __init__.py ===



# === Datei: data_processing\crs.py ===

# data_processing/crs.py

def reproject(gdf, target_crs: str):
    return gdf.to_crs(target_crs)

def compute_bbox(gdf, aspect_ratio: float):
    """
    Berechnet ein Bounding Boxâ€“Tuple (xmin, xmax, ymin, ymax),
    das das gegebene GeoDataFrame mit dem gewÃ¼nschten SeitenverhÃ¤ltnis
    plus 5%-Padding umschlieÃŸt.
    """
    # ursprÃ¼ngliche Bounds
    minx, miny, maxx, maxy = gdf.total_bounds
    width, height = maxx - minx, maxy - miny
    center_x, center_y = (minx + maxx) / 2, (miny + maxy) / 2

    current_ratio = width / height
    if current_ratio > aspect_ratio:
        new_width = width
        new_height = width / aspect_ratio
    else:
        new_height = height
        new_width = height * aspect_ratio

    # 5% Buffer
    new_width *= 1.05
    new_height *= 1.05

    # wirklich zurÃ¼ckgebende Variablen
    xmin = center_x - new_width / 2
    xmax = center_x + new_width / 2
    ymin = center_y - new_height / 2
    ymax = center_y + new_height / 2

    return xmin, xmax, ymin, ymax

# === Datei: data_processing\layers.py ===

# data_processing/layers.py

import pandas as pd
import geopandas as gpd

from pathlib import Path
from typing import List, Dict, Any, Optional


def merge_hauptland_layers(
    gpkg_path: str,
    selected_layers: List[str],
    hide_cfg: Optional[Dict[str, Any]] = None,
    hl_cfg: Optional[Dict[str, Any]] = None,
    crs: str = "EPSG:4326"
) -> gpd.GeoDataFrame:
    """
    LÃ¤dt die ausgewÃ¤hlten Hauptland-Layer, merged sie in ein GeoDataFrame
    und wendet optional Ausblend- und Hervorhebungs-Config an.

    Parameter:
    - gpkg_path: Pfad zur GPKG-Datei
    - selected_layers: Liste der Layer-Namen
    - hide_cfg: Dict mit {'aktiv': bool, 'bereiche': {layer: [region1, ...]}}
    - hl_cfg: Dict mit {'aktiv': bool, 'layer': str, 'namen': [region1, ...]}
    - crs: Ziel-CRS fÃ¼r alle GeoDataFrames

    RÃ¼ckgabe:
    - Geopandas GeoDataFrame mit allen Features (ggf. markiert fÃ¼r Hervorhebung)
    """
    path = Path(gpkg_path)
    dfs = []

    for layer in selected_layers:
        gdf = gpd.read_file(str(path), layer=layer)

        if crs:
            gdf = gdf.to_crs(crs)

        # 1) Ausblenden
        if hide_cfg and hide_cfg.get("aktiv", False):
            bereiche = hide_cfg.get("bereiche", {})
            if layer in bereiche:
                to_hide = set(bereiche[layer])
                gdf = gdf[~gdf["NAME_1"].isin(to_hide)]

        # 2) Hervorheben markieren
        if hl_cfg and hl_cfg.get("aktiv", False):
            if hl_cfg.get("layer") == layer:
                names = set(hl_cfg.get("namen", []))
                gdf["highlight"] = gdf["NAME_1"].isin(names)
            else:
                gdf["highlight"] = False
        else:
            gdf["highlight"] = False

        dfs.append(gdf)

    # 3) Alle DataFrames aneinanderhÃ¤ngen
    merged = pd.concat(dfs, ignore_index=True)
    # Sicherstellen, dass merged ein GeoDataFrame bleibt
    merged = gpd.GeoDataFrame(merged, geometry=dfs[0].geometry.name, crs=dfs[0].crs)

    return merged

# === Datei: gui\auswahlfenster.py ===

# gui/auswahlfenster.py

from typing        import Dict, Any, List
from PySide6.QtCore    import Qt
from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QLineEdit,
    QLabel,
    QPushButton,
    QHBoxLayout
)
from utils.autocomplete import setup_autocomplete
import logging

logger = logging.getLogger("gui.auswahlfenster")
print("â–¶ gui/auswahlfenster.py wird geladen")


class AuswahlFenster(QDialog):
    """
    Dialog zum AuswÃ¤hlen eines Landes/Alias und Ãœbernehmen der
    zugehÃ¶rigen EPSG-Projektion. SchlieÃŸt sich nach OK oder sofort,
    wenn per Autocomplete ein gÃ¼ltiger Eintrag gewÃ¤hlt wurde.
    """

    def __init__(self, epsg_list: List[Dict[str, Any]], parent=None):
        super().__init__(parent)
        self.epsg_list       = epsg_list
        self.epsg_lookup     : Dict[str, Dict[str, Any]] = {}
        self.selected_entry  : Dict[str, Any]            = {}
        self._build_ui()
        logger.debug("EPSG-Liste geladen mit %d EintrÃ¤gen", len(epsg_list))

    def _build_ui(self):
        self.setWindowTitle("LÃ¤nderauswahl mit EPSG")
        layout = QVBoxLayout(self)

        # Label + Eingabe + Ausgabe
        layout.addWidget(QLabel("WÃ¤hle ein Land oder Alias"))
        self.input = QLineEdit()
        layout.addWidget(self.input)

        self.output = QLabel("")
        self.output.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        layout.addWidget(self.output)

        # Lookup-Map + Suchbegriffe sammeln
        suchbegriffe: List[str] = []
        for eintrag in self.epsg_list:
            name = eintrag["land"]
            self.epsg_lookup[name.lower()] = eintrag
            suchbegriffe.append(name)
            for alias in eintrag.get("aliases", []):
                self.epsg_lookup[alias.lower()] = eintrag
                suchbegriffe.append(alias)

        # Autocomplete einrichten
        completer = setup_autocomplete(self.input, suchbegriffe)
        completer.activated[str].connect(self._on_text_selected_and_close)

        # Freitext/Enter validieren
        self.input.textChanged.connect(self._on_text_changed)
        self.input.returnPressed.connect(
            lambda: self._on_text_changed(self.input.text())
        )

        # OK/Abbrechen Buttons
        btn_layout = QHBoxLayout()
        btn_ok = QPushButton("OK")
        btn_ok.clicked.connect(self._on_ok)
        btn_cancel = QPushButton("Abbrechen")
        btn_cancel.clicked.connect(self.reject)
        btn_layout.addWidget(btn_ok)
        btn_layout.addWidget(btn_cancel)
        layout.addLayout(btn_layout)

    def _on_text_selected(self, text: str):
        logger.debug("Vorschlag ausgewÃ¤hlt: %s", text)
        self.input.setText(text)
        self._on_text_changed(text)

    def _on_text_selected_and_close(self, text: str):
        logger.debug("Vorschlag ausgewÃ¤hlt (mit sofortigem SchlieÃŸen): %s", text)
        self.input.setText(text)
        self._on_text_changed(text)
        if self.selected_entry:
            self.accept()

    def _on_text_changed(self, text: str):
        logger.debug("Text geÃ¤ndert: %s", text)
        eintrag = self.epsg_lookup.get(text.lower())
        if eintrag:
            self.selected_entry = {
                "land": eintrag["land"],
                "epsg": f"EPSG:{eintrag['epsg']}",
                "projektion": eintrag.get("projektion", ""),
                "hinweis": eintrag.get("hinweis", "")
            }
            self.output.setText(
                f"EPSG: {self.selected_entry['epsg']}\n"
                f"Projektion: {self.selected_entry['projektion']}"
            )
        else:
            self.selected_entry = {}
            self.output.setText("")

    def _on_ok(self):
        text = self.input.text().strip().lower()
        logger.debug("OK gedrÃ¼ckt â€“ aktueller Text: '%s'", text)

        eintrag = self.epsg_lookup.get(text)
        if not eintrag:
            logger.warning("Kein gÃ¼ltiger Eintrag fÃ¼r '%s'", text)
            self.output.setText("Bitte ein gÃ¼ltiges Land auswÃ¤hlen.")
            self.selected_entry = {}
            return

        self.selected_entry = {
            "land": eintrag["land"],
            "epsg": f"EPSG:{eintrag['epsg']}",
            "projektion": eintrag.get("projektion", ""),
            "hinweis": eintrag.get("hinweis", "")
        }

        logger.debug("GÃ¼ltiger Eintrag bestÃ¤tigt: %s", self.selected_entry)
        self.accept()


# === Datei: gui\dropzones.py ===

# gui/dropzones.py

from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel
from PySide6.QtCore import Qt
from utils.drop_utils import DropZoneLogic

class DropZone(DropZoneLogic):
    """Hier kÃ¶nntest Du GUI-Spezifika ergÃ¤nzen, momentan erbt alles aus DropZoneLogic."""
    pass

class DropPanel(QWidget):
    def __init__(self, copy_to_temp: bool = False):
        super().__init__()
        layout = QVBoxLayout(self)

        self.label_main = QLabel("ðŸ“ Hauptland (.gpkg)")
        self.label_main.setAlignment(Qt.AlignCenter)
        self.drop_main = DropZone(
            "Hauptland", allow_multiple=False, copy_to_temp=copy_to_temp
        )

        self.label_sub = QLabel("ðŸ“ NebenlÃ¤nder (.gpkg)")
        self.label_sub.setAlignment(Qt.AlignCenter)
        self.drop_sub = DropZone(
            "NebenlÃ¤nder", allow_multiple=True, copy_to_temp=copy_to_temp
        )

        layout.addWidget(self.label_main)
        layout.addWidget(self.drop_main)
        layout.addSpacing(15)
        layout.addWidget(self.label_sub)
        layout.addWidget(self.drop_sub)

    def get_main_paths(self) -> list[str]:
        """Alias fÃ¼r drop_main.get_paths() â€“ liefert Liste der Haupt-GPKG-Dateien."""
        return self.drop_main.get_paths()

    def get_sub_paths(self) -> list[str]:
        """Alias fÃ¼r drop_sub.get_paths() â€“ liefert Liste der Neben-GPKG-Dateien."""
        return self.drop_sub.get_paths()

# === Datei: gui\drop_panel.py ===

# gui/drop_panel.py

import os
from PySide6.QtCore    import Qt, Signal
from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QVBoxLayout, QLabel
)

class DropZone(QWidget):
    """
    Einfacher Dropâ€Bereich fÃ¼r Dateien. Signalisiert Ã¼ber dropChanged,
    wenn neue Pfade hereingezogen wurden.
    """
    dropChanged = Signal()

    def __init__(self, title: str, copy_to_temp: bool = False, parent=None):
        super().__init__(parent)
        self.copy_to_temp = copy_to_temp
        self.paths = []

        # UI
        self.label = QLabel(title, self)
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setStyleSheet("border: 2px dashed gray;")
        layout = QVBoxLayout(self)
        layout.addWidget(self.label)

        self.setAcceptDrops(True)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dropEvent(self, event):
        urls = event.mimeData().urls()
        self.paths = [url.toLocalFile() for url in urls]

        # Anzeige aktualisieren
        names = [os.path.basename(p) for p in self.paths]
        self.label.setText("\n".join(names) if names else "Keine Dateien")
        self.dropChanged.emit()

class DropPanel(QWidget):
    """
    Container mit zwei DropZones: Haupt- und Sub-Dateien.
    """
    def __init__(self, copy_to_temp: bool = False, parent=None):
        super().__init__(parent)

        self.drop_main = DropZone("Hauptdatei hierherziehen", copy_to_temp)
        self.drop_sub  = DropZone("Subdateien hierherziehen", copy_to_temp)

        layout = QHBoxLayout(self)
        layout.addWidget(self.drop_main, 1)
        layout.addWidget(self.drop_sub, 1)

    def get_main_paths(self) -> list[str]:
        return self.drop_main.paths

    def get_sub_paths(self) -> list[str]:
        return self.drop_sub.paths

# === Datei: gui\log_viewer.py ===

# gui/log_viewer.py

import logging
from PySide6.QtCore    import QObject, Signal
from PySide6.QtWidgets import QPlainTextEdit

class QTextEditLogger(logging.Handler, QObject):
    """
    Logging-Handler, der EintrÃ¤ge in ein QPlainTextEdit schreibt.
    """
    newRecord = Signal(str)

    def __init__(self, widget: QPlainTextEdit):
        logging.Handler.__init__(self)
        QObject.__init__(self)
        self.widget = widget
        fmt = "%(asctime)s - %(levelname)s - %(message)s"
        self.setFormatter(logging.Formatter(fmt))
        self.newRecord.connect(self.widget.appendPlainText)

    def emit(self, record: logging.LogRecord):
        msg = self.format(record)
        self.newRecord.emit(msg)

# === Datei: gui\main_window.py ===

# gui/main_window.py

import logging
from typing import Any, Dict

from PySide6.QtWidgets import (
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QPlainTextEdit,
)
from gui.drop_panel import DropPanel
from gui.map_canvas import MapCanvas
from gui.log_viewer import QTextEditLogger
from gui.controls.map_settings import MapSettingsGroup
from gui.controls.scalebar_settings import ScalebarSettingsGroup
from gui.controls.background_settings import BackgroundSettingsGroup
from gui.controls.layer_selection import LayerSelectionGroup
from gui.controls.export_settings import ExportSettingsGroup
from utils.config import CONFIG


class MainWindow(QMainWindow):
    def __init__(self, composer: Any, config: Dict[str, Any]) -> None:
        super().__init__()
        self.composer = composer
        self.config   = config

        # -- Setze initial Hintergrund im Composer --
        bg_cfg = self.config.get("background", {})
        self.composer.set_background(
            color=bg_cfg.get("color", "#ffffff"),
            transparent=bg_cfg.get("transparent", False)
        )

        # -- Setze initial Dimensionen im Composer --
        karte_cfg = self.config.get("karte", {})
        self.composer.set_dimensions(
            karte_cfg.get("breite", 800),
            karte_cfg.get("hoehe", 600)
        )

        self._build_ui()
        self._setup_logging()
        self._apply_config_defaults()

    def _build_ui(self) -> None:
        ui_cfg = self.config.get("ui", {})
        self.setWindowTitle(ui_cfg.get("window_title", "mapTool GUI"))
        self.setMinimumSize(800, 600)

        central = QWidget(self)
        self.setCentralWidget(central)

        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(6)

        # 1) DropPanel
        self.drop_panel = DropPanel(copy_to_temp=True)
        main_layout.addWidget(self.drop_panel)

        # 2) Split Canvas & Controls
        content_layout = QHBoxLayout()
        content_layout.setSpacing(6)
        main_layout.addLayout(content_layout)

        # 2a) MapCanvas (nutzt composer.background_cfg & dimensions)
        karte_cfg = self.config.get("karte", {})
        w = karte_cfg.get("breite", 800)
        h = karte_cfg.get("hoehe", 600)
        self.map_canvas = MapCanvas(self.composer, width=w, height=h)
        content_layout.addWidget(self.map_canvas, stretch=3)

        # 2b) Controls-Palette
        controls_layout = QVBoxLayout()
        controls_layout.setSpacing(6)
        content_layout.addLayout(controls_layout, stretch=1)

        # MapSettingsGroup
        self.map_settings = MapSettingsGroup(
            composer=self.composer,
            on_epsg=lambda: None,
            on_dimensions_changed=self._on_dimensions_changed
        )
        self.btn_epsg = self.map_settings.btn_epsg
        self.sp_w     = self.map_settings.sp_w
        self.sp_h     = self.map_settings.sp_h
        controls_layout.addWidget(self.map_settings)

        # ScalebarSettingsGroup
        self.scalebar_settings = ScalebarSettingsGroup(
            composer=self.composer,
            on_changed=lambda _: None
        )
        self.cb_sb_show = self.scalebar_settings.cb_sb_show
        self.cmb_sb_pos = self.scalebar_settings.cmb_sb_pos
        controls_layout.addWidget(self.scalebar_settings)

        # BackgroundSettingsGroup (Button bleibt, ruft nun map_canvas an)
        self.bg_settings = BackgroundSettingsGroup(
            composer=self.composer,
            on_choose_color=lambda: None,
            on_toggled=lambda _: None
        )
        self.btn_col   = self.bg_settings.btn_col
        self.cb_transp = self.bg_settings.cb_transp
        controls_layout.addWidget(self.bg_settings)

        # LayerSelectionGroup
        self.layer_selection = LayerSelectionGroup(
            on_layers_changed=lambda _: None,
            on_hide_changed=lambda _: None,
            on_highlight_changed=lambda _: None
        )
        self.lst_layers = self.layer_selection.lst_layers
        self.lst_hide   = self.layer_selection.lst_hide
        self.lst_high   = self.layer_selection.lst_high
        controls_layout.addWidget(self.layer_selection)

        # ExportSettingsGroup
        self.export_settings = ExportSettingsGroup()
        self.cb_png = self.export_settings.cb_png
        self.cb_svg = self.export_settings.cb_svg
        controls_layout.addWidget(self.export_settings)

        # Log + Render
        self.log_widget = QPlainTextEdit(self)
        self.log_widget.setReadOnly(True)
        controls_layout.addWidget(self.log_widget, stretch=1)

        self.btn_render = QPushButton("Karte rendern", self)
        controls_layout.addWidget(self.btn_render)
        self.btn_render.clicked.connect(self.map_canvas.refresh)

    def _setup_logging(self) -> None:
        handler = QTextEditLogger(self.log_widget)
        logging.getLogger().addHandler(handler)
        lvl = self.config.get("logging", {}).get("level", "INFO").upper()
        logging.getLogger().setLevel(getattr(logging, lvl, logging.INFO))

    def _apply_config_defaults(self) -> None:
        # HinterÂ­grund-Checkbox & FarbÂ­button
        bg_cfg = self.config.get("background", {})
        self.cb_transp.setChecked(bg_cfg.get("transparent", False))
        self.btn_col.hide()

        # Scalebar
        sb = self.config.get("scalebar", {})
        self.cb_sb_show.setChecked(sb.get("show", False))
        self.cmb_sb_pos.setCurrentText(sb.get("position", "bottom-right"))

        # Dimensionen in SpinÂ­boxes & Preview
        karte = self.config.get("karte", {})
        w = karte.get("breite", 800)
        h = karte.get("hoehe", 600)
        self.sp_w.setValue(w)
        self.sp_h.setValue(h)

        self.map_canvas.setFixedSize(w, h)
        self.map_canvas.refresh()

    def _on_dimensions_changed(self, _val: int) -> None:
        w = self.sp_w.value()
        h = self.sp_h.value()
        self.composer.set_dimensions(w, h)
        self.config["karte"]["breite"] = w
        self.config["karte"]["hoehe"]  = h
        self.map_canvas.setFixedSize(w, h)
        self.map_canvas.refresh()

# === Datei: gui\map_builder.py ===

import matplotlib.pyplot as plt
from typing import Optional, List, Dict, Any
from data_processing.layers import merge_hauptland_layers
from data_processing.crs import compute_bbox
from utils.scalebar import add_scalebar


def pixel_to_pt(px, dpi):
    return px * 72.0 / dpi


class MapBuilder:
    def __init__(
        self,
        cfg: Dict[str, Any],
        main_gpkg: Optional[str] = None,
        layers: Optional[List[str]] = None,
        crs: Optional[str] = None,
        hide_cfg: Optional[Dict[str, Any]] = None,
        hl_cfg: Optional[Dict[str, Any]] = None,
        gdf=None,
    ) -> None:
        self.cfg        = cfg
        self.main_gpkg  = main_gpkg
        self.layers     = layers or []
        self.crs        = crs
        self._gdf       = gdf

        # 1) Karten-Abmessungen
        karte          = cfg.get("karte", {})
        self.width_px  = karte.get("breite", 800)
        self.height_px = karte.get("hoehe", 600)

        # 2) Ausblenden / Hervorhebung / Farben / Linien
        self.hide_cfg    = hide_cfg or cfg.get("ausblenden", {})
        self.hl_cfg      = hl_cfg   or cfg.get("hervorhebung", {})
        self.background  = cfg.get("background", {})
        self.colors      = cfg.get("farben", {})
        self.lines_cfg   = cfg.get("linien", {})

        # 3) Scalebar-Defaults sichern
        self._scalebar_defaults = cfg.get("scalebar", {}).copy()

    def build_figure(self) -> plt.Figure:
        # Datenquelle: GUI-Override oder Merge  
        if self._gdf is not None and not self._gdf.empty:
            gdf = self._gdf
        else:
            gdf = merge_hauptland_layers(
                self.main_gpkg,
                self.layers,
                hide_cfg=self.hide_cfg,
                hl_cfg=self.hl_cfg,
                crs=self.crs,
            )

        # Kein Resultat?
        if gdf is None or gdf.empty:
            return self._empty_figure()

        # Haupt- vs. Nebengeometrien
        main_gdf = gdf[gdf["__is_main"]]
        sub_gdf  = gdf[~gdf["__is_main"]]

        # Figure + Achse
        dpi   = self.cfg.get("export", {}).get("dpi", 300)
        fig_w = self.width_px  / dpi
        fig_h = self.height_px / dpi
        fig, ax = plt.subplots(figsize=(fig_w, fig_h), dpi=dpi)
        ax.set_axis_off()

        # Hintergrundfarbe
        if not self.background.get("transparent", False):
            bg = self.background.get("color", "#ffffff")
            fig.patch.set_facecolor(bg)
            ax.set_facecolor(bg)

        # Linienbreiten in Points
        lw_grenze    = pixel_to_pt(self.lines_cfg.get("grenze_px", 1), dpi)
        lw_highlight = pixel_to_pt(self.lines_cfg.get("highlight_px", 1), dpi)

        # 1) NebenlÃ¤nder zeichnen (skip empty)
        if not sub_gdf.empty:
            sub_gdf.plot(
                ax=ax,
                color=self.colors.get("nebenland", "lightgray"),
                edgecolor=self.colors.get("grenze",   "gray"),
                linewidth=lw_grenze,
            )

        # 2) Bounding Box
        aspect = self.width_px / self.height_px
        bbox   = compute_bbox(main_gdf, aspect)
        ax.set_xlim(bbox[0], bbox[1])
        ax.set_ylim(bbox[2], bbox[3])

        # 3) Hauptland
        main_gdf.plot(
            ax=ax,
            color=self.colors.get("hauptland", "white"),
            edgecolor=self.colors.get("grenze",    "gray"),
            linewidth=lw_grenze,
        )

        # 4) Hervorhebungen
        if self.hl_cfg.get("aktiv", False) and "highlight" in main_gdf:
            to_high = main_gdf[main_gdf["highlight"]]
            if not to_high.empty:
                to_high.plot(
                    ax=ax,
                    color=self.colors.get("highlight",  "red"),
                    edgecolor=self.colors.get("grenze",  "darkred"),
                    linewidth=lw_highlight,
                    zorder=3,
                )

        # 5) Scalebar (Defaults + GUI-Override)
        current = self.cfg.get("scalebar", {}) or {}
        scalebar_cfg = {**self._scalebar_defaults, **current}

        if scalebar_cfg.get("show", False):
            extent = [*ax.get_xlim(), *ax.get_ylim()]
            tmp_cfg = {**self.cfg, "scalebar": scalebar_cfg}
            add_scalebar(ax, extent, self.crs, tmp_cfg)

        # 6) RÃ¤nder entfernen (wie save_map)
        fig.subplots_adjust(left=0, right=1, top=1, bottom=0)
        return fig

    def _empty_figure(self) -> plt.Figure:
        fig = plt.figure(
            figsize=(self.width_px / 100, self.height_px / 100)
        )
        fig.text(
            0.5, 0.5, "Keine Daten vorhanden",
            ha="center", va="center"
        )
        return fig

# === Datei: gui\map_canvas.py ===

# gui/map_canvas.py

import logging
from typing import Optional, Any
from PySide6.QtWidgets import QLabel, QSizePolicy
from PySide6.QtCore import Qt
from PySide6.QtGui import QPixmap
from PIL.ImageQt import ImageQt


class MapCanvas(QLabel):
    """
    QLabel, das das von MapComposer gerenderte PIL-Image als QPixmap anzeigt.
    UnterstÃ¼tzt transparente oder farbige HintergrÃ¼nde und zeigt einen
    Platzhaltertext, solange keine Karte geladen ist.
    """

    def __init__(
        self,
        composer: Any,
        width: Optional[int] = None,
        height: Optional[int] = None,
        parent: Optional[Any] = None
    ) -> None:
        super().__init__(parent)
        self.composer = composer

        # Wenn Breite und HÃ¶he Ã¼bergeben, feste GrÃ¶ÃŸe setzen
        if width is not None and height is not None:
            self.setFixedSize(width, height)

        # Platzhalter-Text, solange keine Datei geladen ist
        self._placeholder = "Keine Karte geladen"

        # Standard-Hintergrund aus Composer-Config Ã¼bernehmen
        bg_cfg = getattr(self.composer, "background_cfg", {})
        self._bg_color = bg_cfg.get("color", "#ffffff")
        self._bg_transparent = bg_cfg.get("transparent", False)

        self._init_ui()
        self._apply_background()
        self._show_placeholder()

    def _init_ui(self) -> None:
        """Initialisiert Ausrichtung, Text und GrÃ¶ÃŸen-Policy."""
        self.setText(self._placeholder)
        self.setAlignment(Qt.AlignCenter)
        # Bei festen GrÃ¶ÃŸen kann Expanding entfernt werden, hier bleibt es optional
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

    def _apply_background(self) -> None:
        """
        Setzt das QLabel-Stylesheet entsprechend der
        Transparenz- und Farb-Einstellung.
        """
        if self._bg_transparent:
            self.setStyleSheet("background: transparent;")
        else:
            self.setStyleSheet(f"background-color: {self._bg_color};")

    def set_background(
        self,
        *,
        color: Optional[str] = None,
        transparent: Optional[bool] = None
    ) -> None:
        """
        Wird vom Controller aufgerufen:
        - transparent=True  -> QLabel ist durchsichtig
        - transparent=False -> QLabel zeigt die angegebene Farbe
        """
        if color is not None:
            self._bg_color = color
        if transparent is not None:
            self._bg_transparent = transparent

        self._apply_background()
        self.refresh()

    def refresh(self) -> None:
        """
        LÃ¤dt mit composer.render() die aktuelle Karte neu und zeigt
        sie als QPixmap an. Bei Fehlern oder falls noch kein main_gpkg
        gesetzt ist, wird der Platzhaltertext angezeigt.
        """
        if not getattr(self.composer, "main_gpkg", None):
            self._show_placeholder()
            return

        try:
            pil_img = self.composer.render()
        except Exception as e:
            logging.error("Fehler beim Rendern der Karte: %s", e)
            self._show_placeholder()
            return

        if pil_img is None:
            self._show_placeholder()
            return

        self._show_image(pil_img)

    def _show_placeholder(self) -> None:
        """Zeigt den Platzhalter-Text an."""
        self.clear()
        self.setText(self._placeholder)

    def _show_image(self, img) -> None:
        """
        Konvertiert ein PIL.Image in ein QPixmap und zeigt es.
        """
        qt_img = ImageQt(img)
        pixmap = QPixmap.fromImage(qt_img)
        self.clear()
        self.setPixmap(pixmap)
        self.setAlignment(Qt.AlignCenter)

# === Datei: gui\map_composer.py ===

# gui/map_composer.py

from io import BytesIO
from typing import List, Optional, Dict
from pathlib import Path

from PIL import Image
import matplotlib.pyplot as plt
import pandas as pd
from geopandas import GeoDataFrame

from data_processing.layers import merge_hauptland_layers
from gui.map_builder import MapBuilder
from gui.map_exporter import MapExporter
from utils.layer_selector import get_simplest_layer


class MapComposer:
    def __init__(
        self,
        config: Dict,
        primary_layers: List[str],
        crs: Optional[str] = None
    ) -> None:
        self.config = config
        self.crs = crs or config.get("crs", "EPSG:3857")

        # Dimensionen
        karte_cfg = config.get("karte", {})
        ui_cfg    = config.get("ui", {})
        self.width_px  = karte_cfg.get("breite", ui_cfg.get("default_width", 800))
        self.height_px = karte_cfg.get("hoehe",  ui_cfg.get("default_height", 600))

        # Scalebar
        self.scalebar_cfg = config.get("scalebar", {"show": False})

        # Hintergrund
        bg_cfg = config.get("background", {})
        self.background_cfg = {
            "color":       bg_cfg.get("color", "#ffffff"),
            "transparent": bg_cfg.get("transparent", False),
        }

        # Export-Formate
        self.export_formats = config.get("export", {}).get("formats", ["png"])

        # Hide- und Highlight-Configs
        self.hide_cfg = config.get("hide_cfg", {}) or {"aktiv": False, "bereiche": {}}
        self.hl_cfg   = config.get("highlight_cfg", {}) or {"aktiv": False, "layer": None, "namen": []}

    # ---------- Setter-Methoden ----------

    def set_files(self, main: str, subs: List[str]) -> None:
        """Haupt- und Neben-Geopackages setzen."""
        self.main_gpkg = main
        self.sub_gpkgs = subs or []

    def set_primary_layers(self, layers: List[str]) -> None:
        """Reihenfolge oder Auswahl der primÃ¤ren Layer anpassen."""
        self.primary_layers = list(layers)

    def set_hide(self, hide_map: Dict[str, List[str]]) -> None:
        """
        Ausblendungen konfigurieren.
        hide_map: {layer_name: [feature_name1, feature_name2, ...], ...}
        """
        aktiv = any(hide_map.values())
        self.hide_cfg = {"aktiv": aktiv, "bereiche": hide_map}
        self.config["hide_cfg"] = self.hide_cfg

    def set_highlight(self, layer: str, names: List[str]) -> None:
        """Hervorzuhebenden Layer und Features definieren."""
        aktiv = bool(names)
        self.hl_cfg = {"aktiv": aktiv, "layer": layer, "namen": names}
        self.config["highlight_cfg"] = self.hl_cfg

    def set_scalebar(self, cfg: Dict) -> None:
        """Globale SCALER-Settings aktualisieren und lokal speichern."""
        from utils.config import SCALER
        SCALER.clear()
        SCALER.update(cfg)
        self.scalebar_cfg = dict(cfg)

    def set_background(self, color: Optional[str] = None, transparent: Optional[bool] = None) -> None:
        """Hintergrundfarbe und -transparenz setzen."""
        if color is not None:
            self.background_cfg["color"] = color
        if transparent is not None:
            self.background_cfg["transparent"] = transparent

    def set_dimensions(self, width: int, height: int) -> None:
        """Breite und HÃ¶he (in Pixeln) fÃ¼r Figure-/Canvas-GrÃ¶ÃŸe festlegen."""
        self.width_px = width
        self.height_px = height

    def set_export_formats(self, formats: List[str]) -> None:
        """Export-Formate (z.B. ['png','svg']) festlegen."""
        self.export_formats = list(formats)

    # ---------- Internes ZusammenfÃ¼hren der GDFs ----------

    def _get_combined_gdf(self) -> Optional[GeoDataFrame]:
        """
        LÃ¤dt Haupt- und Neben-GPKGs, merged deren GeoDataFrames
        und liefert ein kombiniertes GeoDataFrame zurÃ¼ck.
        """
        if not getattr(self, "main_gpkg", None):
            return None

        parts = []

        # Haupt-GPKG laden und taggen
        main_gdf = merge_hauptland_layers(
            self.main_gpkg,
            self.primary_layers,
            hide_cfg=self.hide_cfg,
            hl_cfg=self.hl_cfg,
            crs=self.crs
        )
        main_gdf["__is_main"] = True
        parts.append(main_gdf)

        # Sub-GPKGs laden und als NebenlÃ¤nder taggen
        for sub in getattr(self, "sub_gpkgs", []):
            if not sub:
                continue

            layers = get_simplest_layer(sub) or [self.primary_layers[0]]
            sub_gdf = merge_hauptland_layers(
                sub,
                layers,
                hide_cfg=self.hide_cfg,
                hl_cfg=self.hl_cfg,
                crs=self.crs
            )
            sub_gdf["__is_main"] = False
            parts.append(sub_gdf)

        return pd.concat(parts, ignore_index=True)

    # ---------- Composition & Export ----------

    def _create_empty_figure(self) -> plt.Figure:
        """Leere Figure mit Hintergrund-Logik (ohne Geometrien)."""
        dpi = self.config.get("export", {}).get("dpi", 300)
        fig_w = self.width_px / dpi
        fig_h = self.height_px / dpi
        fig, ax = plt.subplots(figsize=(fig_w, fig_h), dpi=dpi)
        ax.set_axis_off()

        if not self.background_cfg["transparent"]:
            fig.patch.set_facecolor(self.background_cfg["color"])
            ax.set_facecolor(self.background_cfg["color"])

        return fig

    def compose(self) -> plt.Figure:
        """
        Baut die aktuelle Karte als Matplotlib-Figure auf.
        Gibt bei fehlender main_gpkg oder keinem GDF eine leere FlÃ¤che zurÃ¼ck.
        """
        if not getattr(self, "main_gpkg", None):
            return self._create_empty_figure()

        combined = self._get_combined_gdf()
        if combined is None or combined.empty:
            return self._create_empty_figure()

        builder = MapBuilder(
            cfg=self.config,
            main_gpkg=None,
            layers=self.primary_layers,
            crs=self.crs,
            hide_cfg=self.hide_cfg,
            hl_cfg=self.hl_cfg,
            gdf=combined
        )

        # UI-Overrides synchronisieren
        builder.width_px     = self.width_px
        builder.height_px    = self.height_px
        builder.background   = self.background_cfg
        builder.scalebar_cfg = self.scalebar_cfg

        return builder.build_figure()

    def compose_and_save(self, output: BytesIO) -> None:
        """
        Schreibt die aktuell erzeugte Figure in den BytesIO-Stream
        in allen konfigurierten Export-Formaten.
        """
        fig = self.compose()
        MapExporter.save(
            fig,
            output,
            self.export_formats,
            transparent=self.background_cfg["transparent"],
        )

    def compose_and_save_dialog(
        self,
        parent=None,
        initial_dir: str = "output"
    ) -> Optional[Path]:
        """
        Ã–ffnet einen Save-Dialog im initial_dir,
        speichert die Figure und Ã¶ffnet danach den Explorer/Finder.
        Gibt den Pfad zur gespeicherten Datei zurÃ¼ck oder None.
        """
        fig = self.compose()
        return MapExporter.save_with_dialog(
            fig,
            self.export_formats,
            transparent=self.background_cfg["transparent"],
            parent=parent,
            initial_dir=initial_dir
        )

    def render(self) -> Image.Image:
        """
        Erstellt eine schnelle Vorschau als PIL.Image fÃ¼r die GUI-Anzeige.
        """
        buffer = BytesIO()
        self.compose_and_save(buffer)
        buffer.seek(0)
        return Image.open(buffer)

# === Datei: gui\map_exporter.py ===

# gui/map_exporter.py

import os
import sys
import subprocess
from pathlib import Path
from typing import Optional

from PySide6.QtWidgets import QFileDialog


class MapExporter:
    @staticmethod
    def save(fig, out, export_formats, transparent: bool):
        """
        Speichert eine Matplotlib-Figure exakt in den vorgegebenen PixelmaÃŸen.

        out:
          - file-like â†’ erstes Format
          - Pfad mit Extension â†’ genau dieses Format
          - Pfad ohne Extension â†’ alle Formate
        """
        fmt_list = list(export_formats)

        # Figure-Rand entfernen
        fig.subplots_adjust(left=0, right=1, top=1, bottom=0)

        # bbox_inches berechnen
        ax = fig.axes[0] if fig.axes else None
        bbox_inches = (
            ax.get_window_extent()
              .transformed(fig.dpi_scale_trans.inverted())
        ) if ax else None

        def _save(path, fmt):
            fig.savefig(
                path,
                format=fmt,
                transparent=transparent,
                dpi=fig.dpi,
                bbox_inches=bbox_inches,
                pad_inches=0
            )

        # file-like?
        if hasattr(out, "write"):
            _save(out, fmt_list[0])
            return

        path = Path(out)
        if path.suffix:
            # Einzeldatei
            path.parent.mkdir(parents=True, exist_ok=True)
            _save(path, path.suffix.lstrip("."))
        else:
            # Ordner + alle Formate
            path.mkdir(parents=True, exist_ok=True)
            for fmt in fmt_list:
                fn = path / f"map.{fmt}"
                _save(fn, fmt)

    @staticmethod
    def save_with_dialog(
        fig,
        export_formats,
        transparent: bool,
        parent=None,
        initial_dir: str = "output"
    ) -> Optional[Path]:
        """
        Ã–ffnet Save-As-Dialog im initial_dir,
        speichert die Figure und Ã¶ffnet den Ordner.
        Gibt den Pfad zur Datei oder None zurÃ¼ck.
        """
        out_dir = Path(initial_dir)
        out_dir.mkdir(parents=True, exist_ok=True)

        fmt_list = list(export_formats)
        pattern = " ".join(f"*.{fmt}" for fmt in fmt_list)
        filter_str = f"Map-Dateien ({pattern})"
        default_fp = out_dir / f"map.{fmt_list[0]}"

        filename, _ = QFileDialog.getSaveFileName(
            parent,
            "Karte speichern",
            str(default_fp),
            filter_str
        )
        if not filename:
            return None

        # Speichern
        MapExporter.save(fig, filename, export_formats, transparent)

        # Ordner im OS-Explorer Ã¶ffnen
        folder = Path(filename).parent
        if sys.platform.startswith("darwin"):
            subprocess.call(["open", str(folder)])
        elif os.name == "nt":
            os.startfile(str(folder))
        else:
            subprocess.call(["xdg-open", str(folder)])

        return Path(filename)

# === Datei: gui\__init__.py ===



# === Datei: gui\controllers\appearance_controller.py ===

# gui/controllers/appearance_controller.py

import logging
from PySide6.QtWidgets import QColorDialog
from utils.config        import save_config

class AppearanceController:
    def __init__(self, composer, view, config, parent):
        self.composer = composer
        self.view     = view
        self.config   = config
        self.parent   = parent

    def choose_bg_color(self):
        col = QColorDialog.getColor(parent=self.parent)
        if not col.isValid():
            return

        # Composer updaten
        self.composer.set_background(color=col.name())
        # Canvas updaten
        self.view.map_canvas.set_background(color=col.name())
        # persistent speichern
        self.config["background"]["color"] = col.name()
        save_config(self.config)

        self.view.map_canvas.refresh()

    def background_changed(self, state: int):
        transparent = bool(state)

        # Composer updaten
        self.composer.set_background(transparent=transparent)
        # Canvas updaten
        self.view.map_canvas.set_background(transparent=transparent)
        # persistent speichern
        self.config["background"]["transparent"] = transparent
        save_config(self.config)

        self.view.map_canvas.refresh()

# === Datei: gui\controllers\epsg_controller.py ===

# gui/controllers/epsg_controller.py

import logging
from PySide6.QtWidgets import QDialog
from gui.auswahlfenster import AuswahlFenster

class EpsgController:
    def __init__(self, composer, view, config, parent):
        self.composer = composer
        self.view      = view
        self.config    = config
        self.parent    = parent

    def select_epsg(self):
        epsg_list = self.config.get("epsg_list", [])
        dlg = AuswahlFenster(epsg_list, parent=self.parent)
        if dlg.exec() != QDialog.Accepted or not dlg.selected_entry:
            return
        new_crs = dlg.selected_entry.get("epsg")
        if not new_crs:
            return

        self.composer.crs = new_crs
        logging.info("Neues CRS gesetzt: %s", new_crs)
        self.view.map_canvas.refresh()

# === Datei: gui\controllers\export_controller.py ===

# gui/controllers/export_controller.py

from pathlib import Path
from gui.map_composer import MapComposer

class ExportController:
    def __init__(self, composer: MapComposer, view, config: dict, parent):
        self.composer = composer
        self.view = view
        self.config = config
        self.parent = parent

    def render_clicked(self) -> None:
        # 1) Export-Formate sammeln
        formats = []
        if self.view.cb_png.isChecked():
            formats.append("png")
        if self.view.cb_svg.isChecked():
            formats.append("svg")
        self.composer.set_export_formats(formats)

        # 2) Abmessungen synchronisieren
        w = self.view.sp_w.value()
        h = self.view.sp_h.value()
        self.composer.set_dimensions(w, h)

        # 3) Speichern per Save-Dialog, Ã¶ffnet danach den Ordner
        saved_path = self.composer.compose_and_save_dialog(
            parent=self.parent,
            initial_dir=self.config.get("output_dir", "output")
        )
        if saved_path:
            # Optional: zuletzt gewÃ¤hlten Ordner merken
            self.config["output_dir"] = str(saved_path.parent)

        # 4) Vorschau aktualisieren
        self.view.map_canvas.refresh()

# === Datei: gui\controllers\file_controller.py ===

# gui/controllers/file_controller.py

import logging
from fiona import listlayers
from PySide6.QtCore import Qt
from PySide6.QtWidgets import QListWidgetItem

class FileController:
    def __init__(self, composer, view):
        self.composer = composer
        self.view = view

    def handle_files_changed(self):
        mains = self.view.drop_panel.get_main_paths()
        subs  = self.view.drop_panel.get_sub_paths()
        logging.debug("Main dropped: %s", mains)
        logging.debug("Subs  dropped: %s", subs)
        if not mains:
            return

        # Composer mit Dateien versorgen
        self.composer.set_files(mains[0], subs)

        # Layer auslesen
        try:
            layer_names = listlayers(mains[0])
        except Exception as e:
            logging.error("Fehler beim Auslesen der Layer: %s", e)
            return

        # UI-Layer-Liste befÃ¼llen
        self.view.lst_layers.clear()
        for name in layer_names:
            item = QListWidgetItem(name)
            item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
            item.setCheckState(Qt.Unchecked)
            self.view.lst_layers.addItem(item)

        # Hide- und Highlight-Listen zurÃ¼cksetzen
        self.view.lst_hide.clear()
        self.view.lst_high.clear()

# === Datei: gui\controllers\layer_controller.py ===

# gui/controllers/layer_controller.py

import logging
from typing import List, Dict

from PySide6.QtCore    import Qt
from PySide6.QtWidgets import QListWidgetItem

from data_processing.layers import merge_hauptland_layers


class LayerController:
    """
    Steuert die Auswahl der Haupt-Layer sowie
    das Ein-/Ausblenden und Hervorheben von Regionen.
    """

    def __init__(self, composer, view):
        self.composer  = composer
        self.view      = view
        self._gdf_main = None
        self._name_col = None

    def handle_primary_selection(self, item: QListWidgetItem) -> None:
        """
        Wird aufgerufen, wenn in lst_layers ein Layer
        angehakt oder abgehakt wird.
        """
        # 1) Alle aktuell angehakten Haupt-Layer
        sel = [
            self.view.lst_layers.item(i).text()
            for i in range(self.view.lst_layers.count())
            if self.view.lst_layers.item(i).checkState() == Qt.Checked
        ]

        # Composer updaten (auch bei leerer Selektion)
        self.composer.set_primary_layers(sel)

        # Wenn nichts angehakt, leere hide/high-Listen und Canvas
        if not sel:
            self.view.lst_hide.clear()
            self.view.lst_high.clear()
            self.view.map_canvas.refresh()
            return

        # 2) GDF der gewÃ¤hlten Haupt-Layer laden
        try:
            gdf = merge_hauptland_layers(
                self.composer.main_gpkg,
                sel,
                hide_cfg={"aktiv": False, "bereiche": {}},
                hl_cfg={"aktiv": False, "layer": "", "namen": []},
                crs=self.composer.crs,
            )
        except Exception as e:
            logging.error("Fehler beim Laden des Haupt-Layers: %s", e)
            return

        # nur die '__is_main' Features behalten
        if "__is_main" in gdf.columns:
            self._gdf_main = gdf[gdf["__is_main"]]
        else:
            self._gdf_main = gdf.copy()

        # 3) Dynamisch ermitteln, welche 'NAME_x'-Spalte genutzt wird
        layer = sel[0]
        lvl   = layer.split("_")[-1]
        col   = f"NAME_{lvl}"
        if col not in self._gdf_main.columns:
            # Fallback: erste Spalte, die mit 'NAME_' beginnt
            candidates = [c for c in self._gdf_main.columns if c.startswith("NAME_")]
            col = candidates[0] if candidates else None
        self._name_col = col

        # 4) EintrÃ¤ge extrahieren und in Listen packen
        if self._name_col:
            raw = (
                self._gdf_main[self._name_col]
                .dropna()
                .astype(str)
                .unique()
            )
            unique_names = sorted(raw)
        else:
            logging.warning("Kein NAME_-Feld gefunden fÃ¼r Layer '%s'", layer)
            unique_names = []

        # 5) Hide- und Highlight-Listen befÃ¼llen
        self.view.lst_hide.clear()
        self.view.lst_high.clear()
        for name in unique_names:
            # Ausblenden
            h_item = QListWidgetItem(name)
            h_item.setFlags(h_item.flags() | Qt.ItemIsUserCheckable)
            h_item.setCheckState(Qt.Unchecked)
            self.view.lst_hide.addItem(h_item)

            # Hervorheben
            x_item = QListWidgetItem(name)
            x_item.setFlags(x_item.flags() | Qt.ItemIsUserCheckable)
            x_item.setCheckState(Qt.Unchecked)
            self.view.lst_high.addItem(x_item)

        # 6) Vorschau neu zeichnen
        self.view.map_canvas.refresh()

    def handle_hide_changed(self, item: QListWidgetItem) -> None:
        """
        Wird aufgerufen, wenn in lst_hide eine Region
        ange- oder abgehakt wird. Aktualisiert Highlight-Liste
        und die Karte.
        """
        # 1) Ausgeblendete Regionen sammeln
        hide_list = [
            self.view.lst_hide.item(i).text()
            for i in range(self.view.lst_hide.count())
            if self.view.lst_hide.item(i).checkState() == Qt.Checked
        ]

        # 2) Composer informieren
        layer = (
            self.composer.primary_layers[0]
            if self.composer.primary_layers else ""
        )
        self.composer.set_hide({layer: hide_list})

        # 3) Highlight-Liste basierend auf hide_list neu befÃ¼llen
        self.view.lst_high.clear()
        if self._name_col:
            raw = (
                self._gdf_main[self._name_col]
                .dropna()
                .astype(str)
                .unique()
            )
            remaining = [n for n in raw if n not in hide_list]
            for name in sorted(remaining):
                item = QListWidgetItem(name)
                item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
                item.setCheckState(Qt.Unchecked)
                self.view.lst_high.addItem(item)

        # 4) Karte neu zeichnen
        self.view.map_canvas.refresh()

    def handle_highlight_changed(self, item: QListWidgetItem) -> None:
        """
        Wird aufgerufen, wenn in lst_high eine Region
        ange- oder abgehakt wird. Aktualisiert Hervorhebung
        in der Karte.
        """
        hl = [
            self.view.lst_high.item(i).text()
            for i in range(self.view.lst_high.count())
            if self.view.lst_high.item(i).checkState() == Qt.Checked
        ]
        layer = (
            self.composer.primary_layers[0]
            if self.composer.primary_layers else ""
        )
        self.composer.set_highlight(layer, hl)
        self.view.map_canvas.refresh()

# === Datei: gui\controllers\main_controller.py ===

from typing       import Any
import sys, logging
from fiona           import listlayers
from PySide6.QtCore    import Qt, Slot
from PySide6.QtWidgets import (
    QApplication,
    QFileDialog,
    QColorDialog,
    QListWidgetItem,
    QDialog,
)

from data_processing.layers       import merge_hauptland_layers
from gui.auswahlfenster           import AuswahlFenster
from utils.config                 import save_config, CONFIG
from .file_controller             import FileController
from .layer_controller            import LayerController
from .settings_controller         import SettingsController
from .appearance_controller       import AppearanceController
from .export_controller           import ExportController
from .epsg_controller             import EpsgController


class MainController:
    def __init__(self, composer: Any, view: Any) -> None:
        self.app        = QApplication.instance() or QApplication(sys.argv)
        self.composer   = composer
        self.view       = view
        self.config     = view.config

        # Subcontroller instanziieren
        self.file_ctrl       = FileController(self.composer, self.view)
        self.layer_ctrl      = LayerController(self.composer, self.view)
        self.settings_ctrl   = SettingsController(self.composer, self.view, self.config)
        self.appearance_ctrl = AppearanceController(self.composer, self.view, self.config, self.view)
        self.export_ctrl     = ExportController(self.composer, self.view, self.config, self.view)
        self.epsg_ctrl       = EpsgController(self.composer, self.view, self.config, self.view)

    def _connect_signals(self) -> None:
        dp = self.view.drop_panel
        dp.drop_main.dropChanged.connect(self.file_ctrl.handle_files_changed)
        dp.drop_sub .dropChanged.connect(self.file_ctrl.handle_files_changed)

        self.view.lst_layers.itemChanged .connect(self.layer_ctrl.handle_primary_selection)
        self.view.lst_hide.itemChanged   .connect(self.layer_ctrl.handle_hide_changed)
        self.view.lst_high.itemChanged   .connect(self.layer_ctrl.handle_highlight_changed)

        self.view.sp_w.valueChanged      .connect(self.settings_ctrl.handle_dimensions_changed)
        self.view.sp_h.valueChanged      .connect(self.settings_ctrl.handle_dimensions_changed)

        self.view.cb_sb_show.stateChanged          .connect(self.settings_ctrl.handle_scalebar_changed)
        self.view.cmb_sb_pos.currentTextChanged    .connect(self.settings_ctrl.handle_scalebar_changed)

        self.view.btn_col.clicked             .connect(self.appearance_ctrl.choose_bg_color)
        self.view.cb_transp.stateChanged      .connect(self.appearance_ctrl.background_changed)

        self.view.btn_render.clicked          .connect(self.export_ctrl.render_clicked)
        self.view.btn_epsg.clicked            .connect(self.epsg_ctrl.select_epsg)

    def run(self) -> int:
        # nach dem Instanziieren aller Subcontroller die Signale verbinden
        self._connect_signals()
        self.view.show()
        return self.app.exec()

# === Datei: gui\controllers\settings_controller.py ===

# gui/controllers/settings_controller.py

from utils.config import save_config

class SettingsController:
    def __init__(self, composer, view, config):
        self.composer = composer
        self.view     = view
        self.config   = config

    def handle_dimensions_changed(self):
        w = self.view.sp_w.value()
        h = self.view.sp_h.value()
        self.composer.set_dimensions(w, h)
        self.view.map_canvas.refresh()

    def handle_scalebar_changed(self):
        show     = self.view.cb_sb_show.isChecked()
        position = self.view.cmb_sb_pos.currentText()

        sb_cfg = self.config.get("scalebar", {}).copy()
        sb_cfg.update({"show": show, "position": position})

        try:
            self.composer.set_scalebar(sb_cfg)
        except AttributeError:
            self.composer.cfg["scalebar"] = sb_cfg

        self.config["scalebar"] = sb_cfg
        save_config(self.config)
        self.view.map_canvas.refresh()

# === Datei: gui\controls\background_settings.py ===

# gui/controls/background_settings.py

from PySide6.QtWidgets import QGroupBox, QHBoxLayout, QPushButton, QCheckBox

class BackgroundSettingsGroup(QGroupBox):
    """
    GroupBox fÃ¼r Hintergrund:
      - Farbe wÃ¤hlen
      - Transparenz on/off
    """
    def __init__(self, composer, on_choose_color, on_toggled, parent=None):
        super().__init__("Hintergrund", parent)
        self.composer = composer
        layout = QHBoxLayout(self)

        # ALS ATTRIBUTE anlegen
        self.btn_col = QPushButton("Farbe wÃ¤hlen", self)
        self.btn_col.clicked.connect(on_choose_color)

        self.cb_transp = QCheckBox("Transparent", self)
        self.cb_transp.setChecked(self.composer.background_cfg["transparent"])
        self.cb_transp.stateChanged.connect(on_toggled)

        layout.addWidget(self.btn_col)
        layout.addWidget(self.cb_transp)

# === Datei: gui\controls\export_settings.py ===

# gui/controls/export_settings.py

from PySide6.QtWidgets import QGroupBox, QHBoxLayout, QCheckBox

class ExportSettingsGroup(QGroupBox):
    """
    GroupBox fÃ¼r Exportâ€Formate:
      - PNG, SVG, â€¦
    """
    def __init__(self, parent=None):
        super().__init__("Export-Formate", parent)
        layout = QHBoxLayout(self)

        self.cb_png = QCheckBox("PNG", self)
        self.cb_png.setChecked(True)

        self.cb_svg = QCheckBox("SVG", self)

        layout.addWidget(self.cb_png)
        layout.addWidget(self.cb_svg)

# === Datei: gui\controls\layer_selection.py ===

# gui/controls/layer_selection.py

from PySide6.QtWidgets import (
    QGroupBox, QHBoxLayout, QVBoxLayout, QLabel, QListWidget
)
from PySide6.QtCore import Qt


def toggle_item_check(item):
    if item.checkState() == Qt.Checked:
        item.setCheckState(Qt.Unchecked)
    else:
        item.setCheckState(Qt.Checked)


class LayerSelectionGroup(QGroupBox):
    """
    GroupBox fÃ¼r Layer-Listen:
      - Haupttitel
      - AusgewÃ¤hlter Layer
      - Ausblenden
      - Hervorheben
    """
    def __init__(self, on_layers_changed, on_hide_changed, on_highlight_changed, parent=None):
        super().__init__("Hauptland: Layer und Gebiete", parent)

        outer = QVBoxLayout(self)
        outer.setSpacing(10)
      
        # Layer-Bereich
        lbl_layer = QLabel("AusgewÃ¤hlter Layer")
        lbl_layer.setStyleSheet("font-weight: bold;")
        outer.addWidget(lbl_layer)

        self.lst_layers = QListWidget(self)
        self.lst_layers.itemChanged.connect(on_layers_changed)
        outer.addWidget(self.lst_layers)

        # Ausblenden / Hervorheben nebeneinander
        row = QHBoxLayout()

        # Ausblenden-Spalte
        col_hide = QVBoxLayout()
        lbl_hide = QLabel("Ausblenden")
        lbl_hide.setStyleSheet("font-weight: bold;")
        col_hide.addWidget(lbl_hide)

        self.lst_hide = QListWidget(self)
        self.lst_hide.itemChanged.connect(on_hide_changed)
        col_hide.addWidget(self.lst_hide)

        # Hervorheben-Spalte
        col_high = QVBoxLayout()
        lbl_high = QLabel("Hervorheben")
        lbl_high.setStyleSheet("font-weight: bold;")
        col_high.addWidget(lbl_high)

        self.lst_high = QListWidget(self)
        self.lst_high.itemChanged.connect(on_highlight_changed)
        col_high.addWidget(self.lst_high)

        row.addLayout(col_hide)
        row.addLayout(col_high)

        outer.addLayout(row)
        
        self.lst_layers.itemClicked.connect(toggle_item_check)
        self.lst_hide.itemClicked.connect(toggle_item_check)
        self.lst_high.itemClicked.connect(toggle_item_check)


# === Datei: gui\controls\map_settings.py ===

# gui/controls/map_settings.py

from PySide6.QtWidgets import QGroupBox, QHBoxLayout, QPushButton, QSpinBox

class MapSettingsGroup(QGroupBox):
    """
    GroupBox fÃ¼r Kartenâ€Settings:
      - EPSGâ€Dialog Ã¶ffnen
      - Breite / HÃ¶he per SpinBox
    """
    def __init__(self, composer, on_epsg, on_dimensions_changed, parent=None):
        super().__init__("Karte", parent)
        self.composer = composer
        layout = QHBoxLayout(self)

        # ALS ATTRIBUTE anlegen
        self.btn_epsg = QPushButton("EPSG wÃ¤hlenâ€¦", self)
        self.btn_epsg.clicked.connect(on_epsg)

        self.sp_w = QSpinBox(self)
        self.sp_w.setRange(100, 5000)
        self.sp_w.setValue(self.composer.width_px)
        self.sp_w.valueChanged.connect(on_dimensions_changed)

        self.sp_h = QSpinBox(self)
        self.sp_h.setRange(100, 5000)
        self.sp_h.setValue(self.composer.height_px)
        self.sp_h.valueChanged.connect(on_dimensions_changed)

        layout.addWidget(self.btn_epsg)
        layout.addWidget(self.sp_w)
        layout.addWidget(self.sp_h)

# === Datei: gui\controls\scalebar_settings.py ===

# gui/controls/scalebar_settings.py

from PySide6.QtWidgets import QGroupBox, QHBoxLayout, QCheckBox, QComboBox
from PySide6.QtCore    import Slot

class ScalebarSettingsGroup(QGroupBox):
    """
    GroupBox fÃ¼r Scalebarâ€Optionen:
      - Anzeigen / Verbergen
      - Position
    """
    def __init__(self, composer, on_changed, parent=None):
        super().__init__("Scalebar", parent)
        self.composer = composer
        layout = QHBoxLayout(self)

        self.cb_sb_show = QCheckBox("Anzeigen", self)
        self.cb_sb_show.setChecked(self.composer.scalebar_cfg["show"])
        self.cb_sb_show.stateChanged.connect(on_changed)

        self.cmb_sb_pos = QComboBox(self)
        self.cmb_sb_pos.addItems(
            ["bottom-left", "bottom-right", "bottom-center", "none"]
        )
        self.cmb_sb_pos.setCurrentText(self.composer.scalebar_cfg["position"])
        self.cmb_sb_pos.currentTextChanged.connect(on_changed)

        layout.addWidget(self.cb_sb_show)
        layout.addWidget(self.cmb_sb_pos)

# === Datei: gui\widgets\map_canvas.py ===

from PySide6.QtWidgets import QLabel
from PySide6.QtGui     import QPixmap
from PIL.ImageQt       import ImageQt
from PySide6.QtCore import Qt

class MapCanvas(QLabel):
    def __init__(self, composer, parent=None):
        super().__init__(parent)
        self.composer = composer
        self.setAlignment(Qt.AlignCenter)

    def refresh(self):
        img     = self.composer.render()
        qt_img  = ImageQt(img)
        pixmap  = QPixmap.fromImage(qt_img)
        self.setPixmap(pixmap)
        self.setFixedSize(pixmap.size())

# === Datei: gui\widgets\__init__.py ===



# === Datei: utils\autocomplete.py ===

# utils/autocomplete.py

from typing import List
from PySide6.QtWidgets import QLineEdit, QCompleter
from PySide6.QtCore import Qt, QStringListModel, QSortFilterProxyModel

def setup_autocomplete(line_edit: QLineEdit, options: List[str]) -> QCompleter:
    """
    Baut fÃ¼r das gegebene QLineEdit einen QCompleter auf, der bei jedem
    Tastendruck filtert und das Popup sofort anzeigt.
    """
    sorted_list  = sorted(options, key=str.lower)
    source_model = QStringListModel(sorted_list, parent=line_edit)

    proxy_model = QSortFilterProxyModel(parent=line_edit)
    proxy_model.setSourceModel(source_model)
    proxy_model.setFilterCaseSensitivity(Qt.CaseInsensitive)
    proxy_model.setFilterRole(Qt.DisplayRole)
    proxy_model.setFilterKeyColumn(0)

    completer = QCompleter(proxy_model, line_edit)
    completer.setCaseSensitivity(Qt.CaseInsensitive)
    completer.setCompletionMode(QCompleter.PopupCompletion)

    line_edit.setCompleter(completer)

    def on_text_edited(text: str):
        proxy_model.setFilterFixedString(text)
        completer.complete()

    line_edit.textEdited.connect(on_text_edited)

    return completer


# === Datei: utils\bbox_helper.py ===

# utils/bbox_helper.py

def compute_bbox(gdf, aspect_ratio: float, padding_factor: float = 0.05):
    minx, miny, maxx, maxy = gdf.total_bounds
    width, height = maxx - minx, maxy - miny
    cx, cy = (minx + maxx) / 2, (miny + maxy) / 2

    current_ratio = width / height
    if current_ratio > aspect_ratio:
        new_width  = width
        new_height = width / aspect_ratio
    else:
        new_height = height
        new_width  = height * aspect_ratio

    new_width  *= 1 + padding_factor
    new_height *= 1 + padding_factor

    xmin = cx - new_width / 2
    xmax = cx + new_width / 2
    ymin = cy - new_height / 2
    ymax = cy + new_height / 2

    return xmin, xmax, ymin, ymax

# === Datei: utils\cli.py ===

# cli.py

import logging
from typing import Tuple, List, Set, Dict, Optional

from rich.logging import RichHandler

logger = logging.getLogger("mymaptool.cli")
logger.setLevel(logging.INFO)
handler = RichHandler(rich_tracebacks=True)
logger.addHandler(handler)


def parse_mode(ans: str) -> bool:
    """
    Parse user input for mode selection.
    Returns:
      False = normal mode
      True  = special mode
    Raises ValueError on invalid input.
    """
    val = ans.strip().lower()
    if val.startswith("n"):
        return False
    if val.startswith("s"):
        return True
    raise ValueError("UngÃ¼ltige Eingabe fÃ¼r Modus. Erwartet 'n' oder 's'.")


BACKGROUND_OPTIONS: List[Tuple[str, Tuple[Optional[str], bool]]] = [
    ("Meeresblau   (#2896BA)", ("#2896BA", False)),
    ("Transparent (PNG-Hintergrund)", (None, True)),
]


def get_background_labels() -> List[str]:
    """
    Return labels for background options in display order.
    """
    return [label for label, _ in BACKGROUND_OPTIONS]


def parse_background_option(choice: int) -> Dict[str, object]:
    """
    Parse background option by 1-based index.
    Returns a dict with keys 'color' and 'transparent'.
    Raises IndexError on invalid index.
    """
    label, (color, transp) = BACKGROUND_OPTIONS[choice - 1]
    return {"color": color or "none", "transparent": transp}


def compute_dimensions(
    is_special: bool,
    config: Dict,
    custom_dimensions: Optional[Tuple[int, int]] = None
) -> Tuple[int, int]:
    """
    Compute map dimensions in pixels.
    - Normal mode: values from config['karte'].
    - Special mode: values from custom_dimensions.
    Raises ValueError if custom_dimensions are invalid.
    """
    if not is_special:
        w = config["karte"]["breite"]
        h = config["karte"]["hoehe"]
        logger.info(f"Normalmodus: Verwende {w}Ã—{h} px aus config.json.")
        return w, h

    if not custom_dimensions or len(custom_dimensions) != 2:
        raise ValueError("FÃ¼r Spezialmodus mÃ¼ssen Breite und HÃ¶he angegeben werden.")
    w, h = custom_dimensions
    if w <= 0 or h <= 0:
        raise ValueError("Spezialmodus: Breite und HÃ¶he mÃ¼ssen grÃ¶ÃŸer als 0 sein.")
    logger.info(f"Spezialmodus: Verwende benutzerdefinierte GrÃ¶ÃŸe {w}Ã—{h} px.")
    return w, h


def get_regions(config: Dict[str, List[str]]) -> List[str]:
    """
    Return a list of region names from config.
    """
    regions = list(config.get("regionen", {}))
    if not regions:
        logger.error("Keine Regionen in der Konfiguration gefunden.")
        raise ValueError("Keine Regionen in der Konfiguration gefunden.")
    return regions


def parse_region(
    choice: int,
    config: Dict[str, List[str]]
) -> Tuple[str, List[str]]:
    """
    Select region by 1-based index.
    Returns (region_name, sublayers_list).
    Raises IndexError on invalid index.
    """
    regions = get_regions(config)
    region_name = regions[choice - 1]
    return region_name, config["regionen"][region_name]


SCALebAR_OPTIONS: List[Tuple[str, Tuple[Optional[str], bool]]] = [
    ("links unten", ("bottom-left", True)),
    ("rechts unten", ("bottom-right", True)),
    ("mitte unten", ("bottom-center", True)),
    ("keine Scalebar", (None, False)),
]


def get_scalebar_labels() -> List[str]:
    """
    Return labels for scalebar options in display order.
    """
    return [label for label, _ in SCALebAR_OPTIONS]


def parse_scalebar_option(choice: int) -> Dict[str, object]:
    """
    Parse scalebar option by 1-based index.
    Returns a dict with keys 'show' and 'position'.
    Raises IndexError on invalid index.
    """
    _, (pos, show) = SCALebAR_OPTIONS[choice - 1]
    return {"show": show, "position": pos or "bottom-left"}


EXPORT_FORMAT_OPTIONS: Dict[int, Set[str]] = {
    1: {"png"},
    2: {"svg"},
    3: {"png", "svg"}
}


def parse_export_formats(choice: int) -> Set[str]:
    """
    Select export formats by 1-based index.
    Returns a set of formats. Defaults to {'png'} on invalid choice.
    """
    return EXPORT_FORMAT_OPTIONS.get(choice, {"png"})

# === Datei: utils\config.py ===

# utils/config.py

import json
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path
from typing import Union

# Basis-Verzeichnis (Projekt-Root)
BASE_DIR = Path(__file__).parent.parent

# Standard-Pfad zur JSON-Konfigurationsdatei
DEFAULT_CONFIG_PATH = BASE_DIR / "config" / "config.json"


def setup_logging(log_cfg: dict):
    """
    Initialisiert das Logging mit RotatingFileHandler.
    Erwartete SchlÃ¼ssel in log_cfg:
      - level: INFO, DEBUG, â€¦
      - file: Pfad zur Log-Datei (relativ zu BASE_DIR oder absolut)
      - maxBytes: maximale DateigrÃ¶ÃŸe in Bytes
      - backupCount: Anzahl der Backups
      - suppress_modules: Liste von Modul-Namen, die auf WARNING gesetzt werden
    """
    level = log_cfg.get("level", "INFO").upper()
    log_file = log_cfg.get("file", "app.log")
    max_bytes = log_cfg.get("maxBytes", 5 * 1024 * 1024)
    backup_count = log_cfg.get("backupCount", 3)

    # Pfad auflÃ¶sen
    log_path = Path(log_file)
    if not log_path.is_absolute():
        log_path = BASE_DIR / log_path

    # Verzeichnis erstellen, falls notwendig
    log_path.parent.mkdir(parents=True, exist_ok=True)

    # Handler und Formatter
    handler = RotatingFileHandler(
        filename=str(log_path),
        maxBytes=max_bytes,
        backupCount=backup_count,
        encoding="utf-8",
    )
    handler.setFormatter(
        logging.Formatter("%(asctime)s %(levelname)s [%(name)s] %(message)s")
    )

    # Root-Logger konfigurieren
    root = logging.getLogger()
    root.setLevel(getattr(logging, level, logging.INFO))
    root.addHandler(handler)

    # Module unterdrÃ¼cken
    for module_name in log_cfg.get("suppress_modules", []):
        logging.getLogger(module_name).setLevel(logging.WARNING)


def load_config(path: Union[str, Path] = None) -> dict:
    """
    LÃ¤dt die JSON-Konfiguration, richtet Logging ein
    und liest optional die EPSG-Liste (assets/epsg_list.json).
    """
    cfg_path = Path(path) if path else DEFAULT_CONFIG_PATH
    if not cfg_path.is_absolute():
        cfg_path = BASE_DIR / cfg_path
    if not cfg_path.exists():
        raise FileNotFoundError(f"Config nicht gefunden: {cfg_path}")

    config = json.loads(cfg_path.read_text(encoding="utf-8"))

    # Logging initialisieren
    log_cfg = config.setdefault("logging", {})
    setup_logging(log_cfg)

    # EPSG-Liste aus assets/epsg_list.json laden
    assets = config.get("assets", {})
    epsg_rel = assets.get("epsg_list")
    if epsg_rel:
        epsg_path = BASE_DIR / epsg_rel
        if epsg_path.exists():
            config["epsg_list"] = json.loads(
                epsg_path.read_text(encoding="utf-8")
            )
        else:
            logging.getLogger(__name__).warning(
                "epsg_list.json nicht gefunden: %s", epsg_path
            )
    else:
        config["epsg_list"] = []

    return config


def save_config(cfg: dict, path: Union[str, Path] = None) -> None:
    """
    Speichert das Config-Dikt ohne 'epsg_list' in die JSON-Datei.
    Wird in main_controller.py via save_config(CONFIG) aufgerufen.
    """
    cfg_path = Path(path) if path else DEFAULT_CONFIG_PATH
    if not cfg_path.is_absolute():
        cfg_path = BASE_DIR / cfg_path

    # Verzeichnis sicherstellen
    cfg_path.parent.mkdir(parents=True, exist_ok=True)

    # Filter: epsg_list nicht mitschreiben
    to_save = {k: v for k, v in cfg.items() if k != "epsg_list"}

    # JSON mit EinrÃ¼ckung schreiben
    cfg_path.write_text(
        json.dumps(to_save, indent=2, ensure_ascii=False),
        encoding="utf-8"
    )




# Beim Import sofort laden â€“ CONFIG enthÃ¤lt alle EintrÃ¤ge aus config.json
CONFIG = load_config()

# Globaler Shortcut fÃ¼r Scalebar-Settings, falls benÃ¶tigt
SCALER = CONFIG.get("scalebar", {})

# === Datei: utils\crs_selector.py ===

# utils/crs_selector.py

import json
from pathlib import Path
from typing import List, Dict, Any, Tuple, Optional

# ModulÂ­verzeichnis (utils/)
BASE_DIR = Path(__file__).resolve().parent

# Pfade zur Konfiguration und zur EPSG-Liste
CONFIG_PATH     = BASE_DIR.parent / "config" / "config.json"
EPSG_LIST_PATH  = BASE_DIR.parent / "assets" / "epsg_list.json"


def load_config(path: Path = CONFIG_PATH) -> Dict[str, Any]:
    """
    LÃ¤dt die Haupt-Konfiguration (config.json) und gibt sie als Dict zurÃ¼ck.
    """
    with path.open(encoding="utf-8") as f:
        return json.load(f)


def get_regions(config: Dict[str, Any]) -> List[str]:
    """
    Gibt eine Liste der in der Konfiguration definierten Regionen zurÃ¼ck.
    """
    return list(config.get("regionen", {}))


def select_region(
    config: Dict[str, Any], index: int
) -> Tuple[str, List[str]]:
    """
    WÃ¤hlt eine Region per 0-based Index aus.
    RÃ¼ckgabe: (regions_name, Sublayer-Keys).
    """
    regions = get_regions(config)
    name = regions[index]
    return name, config["regionen"][name]


def load_epsg_list(path: Path = EPSG_LIST_PATH) -> List[Dict[str, Any]]:
    """
    LÃ¤dt die EPSG-Liste (assets/epsg_list.json) und gibt sie als Liste von Dicts zurÃ¼ck.
    Jeder Eintrag enthÃ¤lt:
      - 'land':       Name des Landes
      - 'epsg':       EPSG-Code (Integer)
      - 'projektion': Beschreibung der Projektion
      - 'hinweis':    ggf. zusÃ¤tzlicher Hinweis
    """
    with path.open(encoding="utf-8") as f:
        return json.load(f)


def get_country_names(epsg_list: List[Dict[str, Any]]) -> List[str]:
    """
    Extrahiert die LÃ¤nderbezeichnungen aus der geladenen EPSG-Liste.
    """
    return [entry["land"] for entry in epsg_list]


def select_country_by_index(
    epsg_list: List[Dict[str, Any]], index: int
) -> Dict[str, Any]:
    """
    WÃ¤hlt ein Land per 0-based Index aus der EPSG-Liste aus.
    RÃ¼ckgabe-Dict enthÃ¤lt:
      - 'land'       (str)
      - 'epsg'       (str im Format 'EPSG:<code>')
      - 'projektion' (str)
      - 'hinweis'    (str)
    """
    entry = epsg_list[index]
    return {
        "land":       entry["land"],
        "epsg":       f"EPSG:{entry['epsg']}",
        "projektion": entry.get("projektion", ""),
        "hinweis":    entry.get("hinweis", ""),
    }


def select_country_by_name(
    epsg_list: List[Dict[str, Any]], name: str
) -> Optional[Dict[str, Any]]:
    """
    WÃ¤hlt ein Land anhand seines Namens aus der EPSG-Liste aus.
    Gibt bei Erfolg das Auswahl-Dict (siehe select_country_by_index) zurÃ¼ck,
    sonst None.
    """
    for entry in epsg_list:
        if entry["land"] == name:
            return {
                "land":       entry["land"],
                "epsg":       f"EPSG:{entry['epsg']}",
                "projektion": entry.get("projektion", ""),
                "hinweis":    entry.get("hinweis", ""),
            }
    return None

# === Datei: utils\datenloader.py ===

import os, json

def get_asset_path(filename):
    base_path = os.path.abspath(os.path.dirname(__file__))
    asset_path = os.path.join(base_path, '..', 'assets', filename)
    return os.path.normpath(asset_path)

def load_epsg_list():
    with open(get_asset_path('epsg_list.json'), 'r', encoding='utf-8') as f:
        return json.load(f)

# === Datei: utils\drop_utils.py ===

# mapTool_gui/utils/drop_utils.py

import os
import shutil
import tempfile
from PySide6.QtCore import Qt, Signal
from PySide6.QtWidgets import QListWidget, QAbstractItemView

class DropZoneLogic(QListWidget):
    """
    Basisklasse fÃ¼r eine Drop-Zone, die .gpkg-Dateien akzeptiert,
    intern Path und optional Kopie verwaltet.
    """
    dropChanged = Signal()

    def __init__(
        self,
        title: str,
        allow_multiple: bool = True,
        copy_to_temp: bool = False,
        parent=None,
    ):
        super().__init__(parent)
        self.title = title
        self.allow_multiple = allow_multiple
        self.copy_to_temp = copy_to_temp

        if self.copy_to_temp:
            self._temp_dir = tempfile.mkdtemp(prefix="maptool_")

        self._setup_ui()

    def _setup_ui(self):
        """Styling & Drag-&-Drop aktivieren."""
        self.setAcceptDrops(True)
        # Nur als Drop-Area nutzen (kein Drag aus dieser Liste)
        self.setDragDropMode(QAbstractItemView.DropOnly)
        self.setStyleSheet(
            """
            QListWidget {
                border: 2px dashed #888;
                padding: 12px;
                background-color: #fafafa;
            }
            """
        )

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            super().dragEnterEvent(event)

    def dragMoveEvent(self, event):
        # Muss separat akzeptiert werden, sonst gilt nur dragEnter
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            super().dragMoveEvent(event)

    def dragLeaveEvent(self, event):
        event.accept()

    def dropEvent(self, event):
        paths = [url.toLocalFile() for url in event.mimeData().urls()]
        gpkg = [p for p in paths if p.lower().endswith(".gpkg")]
        if not gpkg:
            return

        if not self.allow_multiple and len(gpkg) > 1:
            print(f"âš ï¸ In '{self.title}' sind mehrere Dateien nicht erlaubt.")
            return

        added = False
        for src in gpkg:
            name = os.path.basename(src)

            # Original belassen oder in temp kopieren
            if self.copy_to_temp:
                dst = self._unique_temp_path(name)
                shutil.copy2(src, dst)
                store_path = dst
            else:
                store_path = src

            if not self.findItems(name, Qt.MatchExactly):
                self.addItem(name)
                # Kompletter Pfad im UserRole speichern
                self.item(self.count() - 1).setData(Qt.UserRole, store_path)
                added = True

        if added:
            self.dropChanged.emit()

    def _unique_temp_path(self, filename: str) -> str:
        """Erzeugt einen einzigartigen Pfad im Temp-Ordner."""
        base, ext = os.path.splitext(filename)
        dst = os.path.join(self._temp_dir, filename)
        idx = 1
        while os.path.exists(dst):
            dst = os.path.join(self._temp_dir, f"{base}_{idx}{ext}")
            idx += 1
        return dst

    def get_paths(self) -> list[str]:
        """Alle gespeicherten (originalen oder kopierten) Pfade."""
        return [
            self.item(i).data(Qt.UserRole)
            for i in range(self.count())
        ]

# === Datei: utils\io_utils.py ===

# io_utils.py

import os
import geopandas as gpd
from typing import Tuple, List


def find_gpkg_files(
    hauptland_dir: str,
    nebenlaender_dir: str,
    nebenlayer_name: str
) -> Tuple[str, List[gpd.GeoDataFrame]]:
    """
    Findet im Verzeichnis hauptland_dir die erste .gpkg-Datei
    und lÃ¤dt aus nebenlaender_dir alle .gpkg-Dateien als GeoDataFrames
    unter Verwendung des Layers nebenlayer_name.
    Liefert (pfad_haupt_gpkg, [gdf_neben1, gdf_neben2, ...]).
    """
    # Hauptland-GPKG finden
    haupt_files = [f for f in os.listdir(hauptland_dir) if f.endswith(".gpkg")]
    if not haupt_files:
        raise FileNotFoundError(f"Keine .gpkg im Ordner {hauptland_dir}")
    haupt_path = os.path.join(hauptland_dir, haupt_files[0])

    # NebenlÃ¤nder laden
    neben_gdfs: List[gpd.GeoDataFrame] = []
    for fname in os.listdir(nebenlaender_dir):
        if not fname.endswith(".gpkg"):
            continue
        pfad = os.path.join(nebenlaender_dir, fname)
        gdf = gpd.read_file(pfad, layer=nebenlayer_name)
        neben_gdfs.append(gdf)

    return haupt_path, neben_gdfs

# === Datei: utils\layer_selector.py ===

from fiona import listlayers
import geopandas as gpd

def get_simplest_layer(gpkg_path: str) -> list[str]:
    layers = listlayers(gpkg_path)
    if "ADM_ADM_0" in layers:
        return ["ADM_ADM_0"]
    
    # Fallback: Layer mit wenigsten Geometrien
    min_count = float("inf")
    best = None
    for layer in layers:
        try:
            gdf = gpd.read_file(gpkg_path, layer=layer)
            count = len(gdf)
            if count < min_count:
                min_count = count
                best = layer
        except Exception:
            continue
    return [best] if best else []

# === Datei: utils\logging_config.py ===

import logging
import os

def setup_logging(loglevel=logging.DEBUG, logfile="maptool.log"):
    logpath = os.path.join(os.path.dirname(__file__), "..", logfile)
    logpath = os.path.normpath(logpath)

    logging.basicConfig(
        level=loglevel,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
        handlers=[
            logging.FileHandler(logpath, encoding='utf-8'),
            logging.StreamHandler()  # Optional: zeigt Logs auch im Terminal
        ]
    )

# === Datei: utils\plotting.py ===

# plotting.py

import logging
from datetime import datetime
from pathlib import Path
from typing import Tuple, Dict, Set, Optional, List

import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.axes import Axes
from scalebar import add_scalebar

logger = logging.getLogger("mymaptool.plotting")


def pixel_to_pt(pixel: int, dpi: int) -> float:
    """
    Convert pixel units to points based on DPI.
    """
    return pixel * 72 / dpi


def plot_map(
    haupt_gdf,
    neben_gdfs: List,
    highlight_cfg: Dict[str, object],
    colors: Dict[str, str],
    bbox: Tuple[float, float, float, float],
    width_px: int,
    height_px: int,
    src_crs: str,
    label_text: Optional[str] = None,
    scalebar_cfg: Optional[Dict[str, object]] = None,
    background_cfg: Optional[Dict[str, object]] = None,
    linien_cfg: Optional[Dict[str, int]] = None
) -> Tuple[Figure, Axes]:
    """
    Render the map into a Matplotlib Figure and Axes.

    Returns:
        fig: the Matplotlib Figure object
        ax: the Matplotlib Axes object
    """
    dpi = 600
    figsize = (width_px / dpi, height_px / dpi)
    fig, ax = plt.subplots(figsize=figsize, dpi=dpi)
    
    # Background
    if background_cfg:
        bg_color = background_cfg.get("color", "#2896BA")
        bg_transp = background_cfg.get("transparent", False)
    else:
        bg_color = "none"
        bg_transp = True

    fig.patch.set_facecolor(bg_color)
    ax.set_facecolor(bg_color)
    fig.patch.set_alpha(0 if bg_transp else 1)
    ax.patch.set_alpha(0 if bg_transp else 1)

    # Line widths in points
    if linien_cfg:
        linewidth_grenze = pixel_to_pt(linien_cfg.get("grenze_px", 1), dpi)
        linewidth_highlight = pixel_to_pt(linien_cfg.get("highlight_px", 1), dpi)
    else:
        linewidth_grenze = pixel_to_pt(1, dpi)
        linewidth_highlight = pixel_to_pt(1, dpi)

    logger.debug(
        f"LinienstÃ¤rken (pt): Grenze={linewidth_grenze:.2f}, "
        f"Highlight={linewidth_highlight:.2f}"
    )

    # Plot neighbouring countries
    for gdf in neben_gdfs:
        gdf.plot(
            ax=ax,
            color=colors["nebenland"],
            edgecolor=colors["grenze"],
            linewidth=linewidth_grenze
        )

    # Plot main country
    haupt_gdf.plot(
        ax=ax,
        color=colors["hauptland"],
        edgecolor=colors["grenze"],
        linewidth=linewidth_grenze
    )

    # Highlight regions
    if highlight_cfg.get("aktiv") and highlight_cfg.get("namen"):
        mask = haupt_gdf["NAME_1"].isin(highlight_cfg["namen"])
        haupt_gdf[mask].plot(
            ax=ax,
            color=colors["highlight"],
            edgecolor=colors["grenze"],
            linewidth=linewidth_highlight
        )

    # Set bounding box and remove axes
    xmin, xmax, ymin, ymax = bbox
    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    ax.axis("off")

    # Add scalebar if configured
    if scalebar_cfg and scalebar_cfg.get("show", False):
        extent = [*ax.get_xlim(), *ax.get_ylim()]
        add_scalebar(
            ax,
            extent,
            src_crs,
            label=label_text
        )
    else:
        logger.debug("Scalebar disabled or not configured.")

    return fig, ax


def save_map(
    fig: Figure,
    output_dir: Path,
    region: str,
    crs: str,
    width_px: int,
    height_px: int,
    export_formats: Set[str],
    background_cfg: Optional[Dict[str, object]] = None
) -> None:
    """
    Save the map figure to disk in specified formats.

    Dateiname: {region}_{crs}_{timestamp}.{ext}
    """
    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)

    # Build filename base
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    base = f"{region}_{crs.replace(':', '_')}_{timestamp}"
    dpi = 600

    # Resize figure to match pixel dimensions
    fig.set_size_inches(width_px / dpi, height_px / dpi)
    fig.subplots_adjust(left=0, right=1, top=1, bottom=0)

    # Determine bbox_inches
    ax = fig.axes[0] if fig.axes else None
    if ax:
        bbox_inches = (
            ax.get_window_extent()
               .transformed(fig.dpi_scale_trans.inverted())
        )
    else:
        bbox_inches = None

    # Transparency setting
    transparent = True
    if background_cfg:
        transparent = background_cfg.get("transparent", False)

    # Save in requested formats
    for ext in export_formats:
        filepath = output_dir / f"{base}.{ext.lower()}"
        if ext.lower() == "png":
            fig.savefig(
                filepath,
                dpi=dpi,
                transparent=transparent,
                bbox_inches=bbox_inches,
                pad_inches=0
            )
        elif ext.lower() == "svg":
            fig.savefig(
                filepath,
                format="svg",
                bbox_inches=bbox_inches,
                pad_inches=0
            )
        else:
            logger.warning(f"Unbekanntes Format '{ext}' â€“ Ã¼bersprungen.")
            continue

        logger.info(f"Karte gespeichert: {filepath}")

    plt.close(fig)

# === Datei: utils\region_filter.py ===

# utils/region_filter.py

import geopandas as gpd
import fiona
from pathlib import Path
from typing import List, Set, Dict, Any


def list_layers(gpkg_path: Path) -> List[str]:
    """
    Gibt alle Layer-Namen in einem GeoPackage zurÃ¼ck.
    """
    return fiona.listlayers(str(gpkg_path))


def list_region_names(
    gpkg_path: Path,
    layer: str,
    name_field: str = "NAME_1"
) -> List[str]:
    """
    Liest einen Layer aus und gibt alle eindeutigen EintrÃ¤ge
    aus `name_field` sortiert zurÃ¼ck.
    """
    gdf = gpd.read_file(str(gpkg_path), layer=layer)
    names = gdf[name_field].dropna().unique().tolist()
    return sorted(names)


def filter_regions_by_indices(
    region_names: List[str],
    indices: List[int]
) -> List[str]:
    """
    WÃ¤hlt Regionen mittels 0-basierter Indizes aus und
    ignoriert ungÃ¼ltige Indizes.
    """
    return [region_names[i] for i in indices if 0 <= i < len(region_names)]


def compute_hide_config(
    gpkg_path: Path,
    used_layers: List[str],
    layer_choice: int,
    region_indices: List[int]
) -> Dict[str, Any]:
    """
    Baut das Dict fÃ¼r `MapComposer.set_ausblenden()`:
      {
        "aktiv": bool,
        "bereiche": { layer_name: [region1, region2, â€¦] }
      }
    """
    if not (0 <= layer_choice < len(used_layers)):
        return {"aktiv": False, "bereiche": {}}

    layer = used_layers[layer_choice]
    names = list_region_names(gpkg_path, layer, name_field="NAME_1")
    to_hide = filter_regions_by_indices(names, region_indices)

    if not to_hide:
        return {"aktiv": False, "bereiche": {}}

    return {"aktiv": True, "bereiche": {layer: to_hide}}


def compute_highlight_config(
    gpkg_path: Path,
    used_layers: List[str],
    layer_choice: int,
    region_indices: List[int],
    forbidden_names: Set[str] = None,
    name_field: str = "NAME_1"
) -> Dict[str, Any]:
    """
    Baut das Dict fÃ¼r Hervorhebung:
      {
        "aktiv": bool,
        "layer": str,
        "namen": [region1, region2, â€¦]
      }
    Regionen in `forbidden_names` werden ausgeschlossen.
    """
    if not (0 <= layer_choice < len(used_layers)):
        return {"aktiv": False, "layer": "", "namen": []}

    layer = used_layers[layer_choice]
    names = list_region_names(gpkg_path, layer, name_field)

    if forbidden_names:
        names = [n for n in names if n not in forbidden_names]

    to_highlight = filter_regions_by_indices(names, region_indices)
    if not to_highlight:
        return {"aktiv": False, "layer": "", "namen": []}

    return {"aktiv": True, "layer": layer, "namen": to_highlight}

# === Datei: utils\scalebar.py ===

# scalebar.py

import numpy as np
from pyproj import CRS, Transformer

def pixel_to_pt(px: float, dpi: float) -> float:
    """
    Wandelt Pixel in Punkt (pt) um: 1 pt = 1/72 inch.
    """
    return px * 72.0 / dpi

def nice_number(x: float) -> float:
    """
    Rundet x auf eine â€žschÃ¶neâ€œ Zahl (1, 2, 5 Ã— 10^n).
    """
    if x <= 0:
        return 0
    exp = np.floor(np.log10(x))
    f   = x / 10**exp
    if f < 1.5:   nice_f = 1
    elif f < 3:   nice_f = 2
    elif f < 7:   nice_f = 5
    else:         nice_f = 10
    return nice_f * 10**exp

def add_scalebar(ax, extent, src_crs, config):
    """
    Zeichnet eine dynamisch skalierte Scalebar in Achsenkoordinaten.
    extent: [xmin, xmax, ymin, ymax] in Daten-Koordinaten
    src_crs: CRS-String oder EPSG-Code der Daten
    config: gesamtes Config-Dict (enthÃ¤lt scalebar- und karte-Sektion)
    """
    scalebar_cfg = config.get("scalebar", {})
    if not scalebar_cfg.get("show", False):
        return

    # 1) Kartenbreite in Meter berechnen
    crs_obj = CRS.from_user_input(src_crs)
    if crs_obj.is_geographic:
        transformer = Transformer.from_crs(crs_obj, "EPSG:3857", always_xy=True)
        xmin_m, ymin_m = transformer.transform(extent[0], extent[2])
        xmax_m, ymax_m = transformer.transform(extent[1], extent[3])
    else:
        xmin_m, xmax_m, ymin_m, ymax_m = extent
    map_width_m = xmax_m - xmin_m

    # 2) Achsenabmessungen in Pixel
    fig  = ax.figure
    bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())
    axes_w_px = bbox.width  * fig.dpi
    axes_h_px = bbox.height * fig.dpi

    # 3) Roh-Pixel-LÃ¤nge & clamp zwischen min/max
    frac_cfg = scalebar_cfg.get("length_fraction", 0.07)
    raw_px   = frac_cfg * axes_w_px
    min_px   = scalebar_cfg.get("min_length_px", 50)
    max_px   = scalebar_cfg.get("max_length_px", 200)
    target_px = max(min(raw_px, max_px), min_px)

    # 4) ZurÃ¼ck in Meter + â€žschÃ¶neâ€œ LÃ¤nge finden
    target_m  = (target_px / axes_w_px) * map_width_m
    nice_len_m = nice_number(target_m)
    frac_nice  = nice_len_m / map_width_m

    # 5) Label (m oder km)
    if nice_len_m >= 1000:
        label = f"{int(nice_len_m/1000)} km"
    else:
        label = f"{int(nice_len_m)} m"

    # 6) Stift- und SchriftgrÃ¶ÃŸen in pt
    dpi      = fig.dpi or scalebar_cfg.get("dpi", 72)
    lw_px    = scalebar_cfg.get("linewidth_px", 1.5)
    font_px  = scalebar_cfg.get("font_px", 16)
    lw_pt    = pixel_to_pt(lw_px, dpi)
    font_pt  = pixel_to_pt(font_px, dpi)
    color    = scalebar_cfg.get("color", "black")
    tick_frac = scalebar_cfg.get("tick_fraction", 0.05)
    pad_px   = scalebar_cfg.get("padding_px", 20)
    pad_x    = pad_px / axes_w_px
    pad_y    = pad_px / axes_h_px

    # 7) Position in Achsen-Koordinaten wÃ¤hlen
    pos_map = {
        "bottom-left":   (0.05, 0.05),
        "bottom-center": (0.50, 0.05),
        "bottom-right":  (0.95, 0.05),
        "top-left":      (0.05, 0.95),
        "top-center":    (0.50, 0.95),
        "top-right":     (0.95, 0.95),
    }
    x0, y0 = pos_map.get(scalebar_cfg.get("position", "bottom-right"),
                         (0.05, 0.05))

    # 8) Randabstand und Ãœberlauf korrigieren
    if x0 + frac_nice > 1.0 - pad_x:
        x0 = 1.0 - frac_nice - pad_x
    if x0 < pad_x:
        x0 = pad_x
    if y0 < pad_y:
        y0 = pad_y
    if y0 > 1.0 - pad_y:
        y0 = 1.0 - pad_y

    # 9) Zeichnen: Linie
    ax.plot(
        [x0, x0 + frac_nice],
        [y0, y0],
        transform=ax.transAxes,
        color=color,
        linewidth=lw_pt,
        solid_capstyle="butt",
        zorder=5
    )

    # 10) End-Ticks
    tick_h = tick_frac * frac_nice
    for xx in (x0, x0 + frac_nice):
        ax.plot(
            [xx, xx],
            [y0, y0 + tick_h],
            transform=ax.transAxes,
            color=color,
            linewidth=lw_pt,
            zorder=5
        )

    # 11) Beschriftung
    ax.text(
        x0 + frac_nice / 2,
        y0 + tick_h * 1.5,
        label,
        transform=ax.transAxes,
        ha="center",
        va="bottom",
        fontsize=font_pt,
        color=color,
        zorder=5
    )

# === Datei: utils\__init__.py ===

